use actix_web::{web, HttpResponse, Responder};
use bson::doc;
use mongodb::Client;
use std::{env, sync::Arc};

use crate::{middleware::auth::Claims, models::account::User};

pub async fn personal_information(
    data: web::Data<Arc<Client>>,
    claims: Claims,
    path: web::Path<(String,)>,
    input: web::Json<User>,
) -> impl Responder {
    if path.into_inner().0 != claims.user_id {
        return HttpResponse::Forbidden().body("Forbidden");
    }

    let client = data.into_inner();

    let collection: mongodb::Collection<User> =
        client.database("Account").collection("UserTraveler");

    let mut info = input.into_inner();
    info.updated_at = Some(chrono::Utc::now());

    let updates = bson::to_document(&info).unwrap();

    let filter = doc! { "_id": claims.user_id.clone() };
    match collection.update_one(filter, updates).await {
        Ok(_) => {
            return HttpResponse::Ok().body("User information updated");
        }
        Err(_) => {
            return HttpResponse::InternalServerError().body("Failed to update user information")
        }
    }
}

pub async fn upload_profile_pic(
    data: web::Data<Arc<Client>>,
    claims: Claims,
    payload: web::Payload,
) -> impl Responder {
    let client = data.into_inner();

    if let Some(image_bytes) = image_data {
        let bucket_name = env::var("PROFILE_PIC_BUCKET").unwrap_or("".to_string());
    }

    let collection: mongodb::Collection<User> = client.database("Account").collection("User");

    let filter = doc! { "_id": claims.user_id.clone() };
    let updates = doc! { "$set": { "profile_picture": "profile_picture.jpg" } };

    match collection.update_one(filter, updates).await {
        Ok(_) => {
            return HttpResponse::Ok().body("Profile picture updated");
        }
        Err(_) => {
            return HttpResponse::InternalServerError().body("Failed to update profile picture")
        }
    }
}
